#' get_capd_intervals
#'
#' Takes data fram from \link{load_capd} and creates intervals for each patient
#' encounter. Each interval contains the Cornell Assessment of Pediatric
#' Delirium (CAPD) score, as well as the duration of time spent at that
#' interval. Some processing is incorporated to take comatose times into
#' account, during which a CAPD cannot be scored.
#'
#' An interval will last at most max_ep_duration if nothing else is charted.
#'
#' Please note that if coma_times are used, all CAPD measurements that were
#' documented during periods where RASS was -4 or -5 will be eliminated. This is
#' appropriate as CAPD should not be scored during these times.  Howwever, if
#' max_inter_ep_duration is also used, this means that the duration of a CAPD
#' interval can be extended into a comatose period by this many hours (default
#' 12, for once per shift). This is akin to a last one carried forward approach
#' (LOCF), truncated after a certain period of time.
#'
#' @param id A character vector of IDs for each unique patient or encounter.
#'   Generally taken from the variable PAT_ENC_CSN_ID, but can also create
#'   custom IDs. An example would be to use PAT_ENC_CSN_ID but also append an
#'   identifier (01, 02, 03, etc.) for each PICU hospitalization or episode of
#'   invasive mechanical ventilation.
#' @param capd A vector of integers ranging from 0 to 32, representing the CAPD
#'   for each patient.
#' @param capd_time A vector of datetime or POSIXct entries corresponding to
#'   each CAPD value
#' @param coma_times A data frame containing 3 columns: id, POSIXct objects
#'   corresponding to start/stop times when RASS is -4 or -5. CAPD is undefined
#'   at this time. If \code{NULL} then this will be skipped. This data frame can
#'   be generated by the function \link{get_rass_intervals} with a little
#'   processing.
#' @param max_inter_ep_duration The maximum number of hours that a particular
#'   CAPD will be extended in the event of a null recording. The default is 12
#'   hours (protocol is to check CAPD once per shift). CAPD may be sparsely
#'   recorded. For any recorded CAPD, the current CAPD will be carried forward
#'   for \code{max_inter_ep_duration} hours. After this amount of time, the
#'   interval will be ended. Set this variable to 0 and no intervals will be
#'   created. Set it to NA and the interval will be extended forward
#'   indefinitely until a new CAPD is recorded.
#'
#' @return A data frame with:
#' \itemize{
#'   \item \code{id}: The ID of the patient.
#'   \item \code{capd_episode}: The number of each CAPD interval (1, 2, 3, ..., k) for k intervals per ID
#'   \item \code{capd}: The CAPD
#'   \item \code{capd_time_start}: The start datetime of each interval
#'   \item \code{capd_time_stop}: The end datetime of each interval
#'   \item \code{capd_duration}: A \code{\link[lubridate]{duration}} object representing the duration of this interval
#'   \item \code{delirious}: A logical representing whether the patient is or isn't delirious at this time
#'   }
#' @export

get_capd_intervals <- function(id, capd, capd_time, coma_times=NULL, max_inter_ep_duration = 12) {

     # ***************************************************************
     # Initialize variables ------------------------------------------
     # ***************************************************************
     capd_change <- capd_episode <- capd_time_start <- capd_time_stop <-
          timetonext <- x <- y <- df_coma_times <- df_rass <-
               rass_time_start <- rass_time_stop <- coma_time_start <-
          coma_time_stop <- NULL


     # ***************************************************************
     # Error-catching ------------------------------------------------
     # ***************************************************************

     # Make sure variable ID is a character
     tryCatch({

          if(!is.character(id)) {
               id <- as.character(id)
          }
     },
     error = function(e) {
          cat('Error: variable \'id\' must either be a character, or be coercible to a character.')
          return(NULL)
     })

     # Make sure variable capd is an integer
     tryCatch({
          if(!is.integer(capd)) {
               capd <- as.integer(capd)
          }
     },
     error = function(e) {
          cat('Error: variable \'capd\' must either be an integer, or be coercible to an integer')
          return(NULL)
     })

     # Make sure variable capd_time is a datetime
     tryCatch({
          if(!lubridate::is.POSIXct(capd_time)) {
               capd_time <- lubridate::as_datetime(capd_time)
          }
     },
     error = function(e) {
          cat('Error: variable \'capd_time\' must be coercible to a datetime (POSIXct) format')
          return(NULL)
     })

     # Make sure all variables have the same length
     lengths <- c(length(id), length(capd), length(capd_time))
     if(length(unique(lengths)) > 1) {
          stop('Error: id, capd, and capd_time all must be the same length')
     }


     # ***************************************************************
     # Create the data frame -----------------------------------------
     # ***************************************************************

     # Create the data frame to export. Remove any row with NA data.
     # Also remove negative numbers
     df_capd <- tibble(id = id, capd = capd, capd_time = capd_time) %>%
          filter(!is.na(capd)) %>%
          filter(capd >= 0) %>%
          arrange(id, capd_time)

     # Remove any CAPD measures that were taken during periods of coma
     if(!is.null(coma_times)) {
          anti_capd_coma_join <- join_by(id, dplyr::between(capd_time, coma_time_start, coma_time_stop, bounds = "[]"))
          df_capd <- anti_join(df_capd, coma_times, by = anti_capd_coma_join) %>%
               distinct()
     }

     # Find times where the CAPD changes and number the episodes
     df_capd <- df_capd %>%
          group_by(id) %>%
          mutate(capd_change = capd != lag(capd, default = FALSE),
                 capd_episode = cumsum(capd_change*1)) %>%
          ungroup()

     # Get the start and stop of each "interval" of CAPD.
     # Also find the time until the "next" interval.
     df_capd <- df_capd %>%
          group_by(id, capd_episode) %>%
          dplyr::reframe(capd = max(capd),
                  capd_time_start = min(capd_time),
                  capd_time_stop = max(capd_time)) %>%
          group_by(id) %>%
          mutate(timetonext = (lead(capd_time_start, default = max(capd_time_stop)) - capd_time_stop)/lubridate::dhours(1)) %>%
          ungroup()

     # Update the end time of each interval to be end of this interval plus max_inter_ep_duration, or
     # else the time when the next interval started (whichever came first).
     # As a reminder, if max_inter_ep_duration is NA, then it will default to extending each interval
     # until the start of the next CAPD. (The final CAPD will be unchanged.)
     # If max_inter_ep_duration is zero, then no intervals are extended.
     df_capd <- df_capd %>%
          group_by(id) %>%
          mutate(capd_time_stop = pmin(capd_time_stop + hours(max_inter_ep_duration),
                                       lead(capd_time_start, default = max(capd_time_stop)), na.rm = TRUE),
                 capd_interval_duration = as.duration(interval(capd_time_start, capd_time_stop))
          ) %>%
          select(-timetonext) %>%
          ungroup()

     # Set 1st episode number to 1 by default
     df_capd <- df_capd %>%
          group_by(id) %>%
          arrange(id, capd_time_start) %>%
          mutate(capd_episode = row_number(capd_episode)) %>%
          ungroup()


     # # Join capd intervals with comatose intervals. A full join using overlap
     # # will ensure that all rows in X and Y (capd and coma datasets) will be
     # # present. However, the overlap ensures that if the interval of coma overlaps at
     # # all with capd, then they will be joined to a single row. This means that
     # # we can then make some rules about which type of interval supercedes another.
     # capd_rass_join <- join_by(id == id, overlaps(x$capd_time_start, x$capd_time_stop, y$coma_time_start, y$coma_time_stop, bounds = '[)'))
     # df_capd_coma <- full_join(df_capd_temp, df_coma_times, by = capd_rass_join)
     #
     # # Now we have overlapping intervals in the same row. We need to make it so
     # # that, whenever capd overlaps with the beginning of a coma period, we will
     # # truncate it
     # df_capd_coma <- df_capd_coma %>%
     #      mutate(capd_time_stop = if_else(capd_time_stop > coma_time_start, coma_time_start, capd_time_stop, capd_time_stop),
     #             capd_time_start = if_else(capd_time_start < coma_time_stop)

     # Label times of delirium
     df_capd <- df_capd %>%
          mutate(delirious = capd >= 9)

     return(df_capd)
}
